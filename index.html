<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cygnet</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦¢</text></svg>">
    <style>
        .sense-box:hover {
            border-color: #60a5fa !important;
        }
        .sense-box:has(.concept-inner:hover) {
            border-color: #e5e7eb !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Helper to get chunk file path for an ID
        const getChunkPath = (id, type) => {
            const numId = parseInt(id);
            const chunkNum = Math.floor(numId / 100);
            const chunkStr = chunkNum.toString().padStart(5, '0');
            const dir = chunkStr.slice(0, 3);
            return `website_data/${type}/${dir}/${chunkStr}.json`;
        };

        // Get prefix for a word (1 char for single letters, 2 chars otherwise)
        const getPrefix = (word) => {
            if (!word) return '';
            const lower = word.toLowerCase();
            if (lower.length === 1) return lower;
            return lower.slice(0, 2);
        };

        // Remove accents from text for search normalization
        const remove_accents = (text) => {
            return text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        };

        // Map POS codes to human readable names
        const posToHumanReadable = {
            'NOUN': 'Noun',
            'VERB': 'Verb',
            'ADJ': 'Adjective',
            'ADV': 'Adverb',
            'CONJ': 'Conjunction',
            'ADP': 'Adposition',
            'NREF': 'Non-referential',
            'UNK': 'Unknown'
        };

         const relationNames = {
            // Sense relations
            'ant': 'antonym',
            'der': 'derivation',
            'ptr': 'pertainym',
            'prt': 'participle',
             'syn': 'synonym',

            // Concept relations
            'hyp': 'class hypernym',
            'ihyp': 'instance hypernym',
            'mmer': 'member meronym',
            'pmer': 'part meronym',
            'smer': 'substance meronym',
            'opp': 'opposite',
            'cau': 'causes',
            'ent': 'entails',
            'aga': 'agent of action',
            'paa': 'patient of action',
            'rea': 'result of action',
            'iag': 'instrument of agent',
            'iac': 'instrument of action',
            'rag': 'result of agent',
            'pag': 'patient of agent',
            'ipa': 'instrument of patient',
            'ire': 'instrument of result',
            'pre': 'patient of result'
        };

        const relationColors = {
            'ant': '#ef4444',      // red
            'der': '#f59e0b',      // amber
            'ptr': '#10b981',      // emerald
            'prt': '#06b6d4',      // cyan
            'syn': '#10b981',      // emerald (or choose another color)

            'hyp': '#3b82f6',      // blue
            'ihyp': '#6366f1',     // indigo
            'mmer': '#8b5cf6',     // violet
            'pmer': '#a855f7',     // purple
            'smer': '#d946ef',     // fuchsia
            'opp': '#ec4899',      // pink
            'cau': '#f43f5e',      // rose
            'ent': '#14b8a6',      // teal
            'aga': '#84cc16',      // lime
            'paa': '#22c55e',      // green
            'rea': '#eab308',      // yellow
            'iag': '#f97316',      // orange
            'iac': '#dc2626',      // red-600
            'rag': '#059669',      // emerald-600
            'pag': '#0891b2',      // cyan-600
            'ipa': '#4f46e5',      // indigo-600
            'ire': '#7c3aed',      // violet-600
            'pre': '#9333ea'       // purple-600
        };

        function DictionaryBrowser() {
            const [prefixMap, setPrefixMap] = useState(null);
            const [loadedPrefixLookups, setLoadedPrefixLookups] = useState({});
            const [loadedConceptChunks, setLoadedConceptChunks] = useState({});
            const [loadedSenseChunks, setLoadedSenseChunks] = useState({});
            const [allLanguages, setAllLanguages] = useState([]);
            const [error, setError] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [currentSearch, setCurrentSearch] = useState('');
            const [languageFilter, setLanguageFilter] = useState(new Set());
            const [posFilter, setPosFilter] = useState(new Set());
            const [senseFilter, setSenseFilter] = useState(null);
            const [selectedConcept, setSelectedConcept] = useState(null);
            const [selectedSense, setSelectedSense] = useState(null);
            const [view, setView] = useState('search');
            const [loadingResults, setLoadingResults] = useState(false);
            const [loadedSenses, setLoadedSenses] = useState({});
            const [activeTab, setActiveTab] = useState('browser');
            const [collapsedSections, setCollapsedSections] = useState({});
            const [synonymsCollapsed, setSynonymsCollapsed] = useState(() => ({}));
            const [definitionLanguage, setDefinitionLanguage] = useState(() => {
                return localStorage.getItem('definitionLanguage') || 'en';
            });
            const isPopStateRef = React.useRef(false);
            const isInitialLoadRef = React.useRef(true);
            const [langCodes, setLangCodes] = useState({});
            const [relatedConcepts, setRelatedConcepts] = useState({});
            const [visibleNodes, setVisibleNodes] = useState(new Set());
            const [hoveredNode, setHoveredNode] = useState(null);
            const [hoverMenuPosition, setHoverMenuPosition] = useState(null);
            const [selectedCategories, setSelectedCategories] = useState({});
            const hoverTimeoutRef = React.useRef(null);
            const isLoadingRelationsRef = React.useRef(false);
            const simulationRef = React.useRef(null);
            const svgRef = React.useRef(null);
            const gRef = React.useRef(null);
            const lastConceptRef = React.useRef(null);
            const setHoverMenuPositionRef = React.useRef(null);
            setHoverMenuPositionRef.current = setHoverMenuPosition;
            const menuRef = React.useRef(null);
            const menuInteractionRef = React.useRef(false);

            const relationsMap = relatedConcepts[selectedConcept];
            let hasRelationsToDisplay = false;

            // Check if data is present and if any relation list has a length > 0
            if (relationsMap) {
                for (const key in relationsMap) {
                    // We assume relationsMap[key] is an array of related concepts
                    if (Array.isArray(relationsMap[key]) && relationsMap[key].length > 0) {
                        hasRelationsToDisplay = true;
                        break;
                    }
                }
            }

            const nodeSizeCache = React.useRef(new Map());
            const MAX_CACHE_SIZE = 200; // Limit cache entries

            const addToCache = (key, value) => {
                const cache = nodeSizeCache.current;
                // If cache is full, delete oldest entry
                if (cache.size >= MAX_CACHE_SIZE) {
                    const firstKey = cache.keys().next().value;
                    cache.delete(firstKey);
                }
                cache.set(key, value);
            };

            const hoveredNodeRef = React.useRef(null);
            useEffect(() => {
                hoveredNodeRef.current = hoveredNode;
            }, [hoveredNode]);

            const getLangName = (langCode) => {
                return langCodes[langCode] || langCode.toUpperCase();
            };
            const getPosName = (posCode, capitalize = false) => {
                const names = {
                    'NOUN': 'noun',
                    'VERB': 'verb',
                    'ADJ': 'adjective',
                    'ADV': 'adverb',
                    'CONJ': 'conjunction',
                    'ADP': 'adposition',
                    'NREF': 'non-referential',
                    'UNK': 'unknown'
                };
                const name = names[posCode] || posCode.toLowerCase();
                return capitalize ? name.charAt(0).toUpperCase() + name.slice(1) : name;
            };

            // Toggle collapse state for a section
            const toggleSection = (key) => {
                setCollapsedSections(prev => ({
                    ...prev,
                    [key]: !prev[key]
                }));
            };

            // Toggle synonyms for a sense
            const toggleSynonyms = (senseId) => {
                setSynonymsCollapsed(prev => ({
                    ...prev,
                    [senseId]: prev[senseId] === false ? true : false
                }));
            };


            const loadConcept = React.useCallback(async (conceptId) => {
                const chunkPath = getChunkPath(parseInt(conceptId), 'concepts');

                if (loadedConceptChunks[chunkPath]?.[conceptId]) {
                    return loadedConceptChunks[chunkPath][conceptId];
                }

                try {
                    let chunkData = loadedConceptChunks[chunkPath];

                    if (!chunkData) {
                        const response = await fetch(chunkPath);
                        chunkData = await response.json();
                        setLoadedConceptChunks(prev => ({ ...prev, [chunkPath]: chunkData }));
                    }

                    const conceptData = chunkData?.[conceptId];

                    // Preload all senses for this concept
                    if (conceptData?.s) {
                        for (const lang in conceptData.s) {
                            for (const senseId of conceptData.s[lang]) {
                                loadSense(senseId.toString());
                            }
                        }
                    }

                    return conceptData;
                } catch (err) {
                    console.error('Error loading concept:', err);
                    return null;
                }
            }, [loadedConceptChunks]);

            const getConceptData = (conceptId) => {
                const chunkPath = getChunkPath(parseInt(conceptId), 'concepts');
                return loadedConceptChunks[chunkPath]?.[conceptId];
            };

            const loadConceptRelations = React.useCallback(async (conceptId, conceptData = null) => {
                const concept = conceptData || getConceptData(conceptId);
                if (!concept) return {};

                const relations = {};

                // Collect direct concept relations from the concept's cr field
                if (concept.cr) {
                    for (const rel of concept.cr) {
                        const relType = rel.t;
                        const targetConceptId = rel.to.toString();

                        if (!relations[relType]) relations[relType] = new Set();
                        relations[relType].add(targetConceptId);

                        // Preload the target concept
                        loadConcept(targetConceptId);
                    }
                }

                // Convert Sets to Arrays
                const relationsArray = {};
                for (const relType in relations) {
                    relationsArray[relType] = Array.from(relations[relType]);
                }

                return relationsArray;
            }, [loadedConceptChunks]);

            const categorizeRelations = React.useCallback((relations) => {
                const categories = {
                    hypernyms: [],
                    hyponyms: [],
                    meronyms: [],
                    holonyms: [],
                    roles: [],
                    inferences: [],
                    opposites: []
                };

                for (const relType in relations) {
                    const targets = relations[relType];
                    const isInverse = relType.startsWith('-');
                    const baseType = isInverse ? relType.substring(1) : relType;

                    if (baseType === 'hyp' || baseType === 'ihyp') {
                        if (isInverse) {
                            categories.hyponyms.push(...targets.map(t => ({ type: relType, target: t })));
                        } else {
                            categories.hypernyms.push(...targets.map(t => ({ type: relType, target: t })));
                        }
                    } else if (baseType === 'mmer' || baseType === 'pmer' || baseType === 'smer') {
                        if (isInverse) {
                            categories.holonyms.push(...targets.map(t => ({ type: relType, target: t })));
                        } else {
                            categories.meronyms.push(...targets.map(t => ({ type: relType, target: t })));
                        }
                    } else if (baseType === 'aga' || baseType === 'paa' || baseType === 'rea' ||
                               baseType === 'iag' || baseType === 'iac' || baseType === 'rag' ||
                               baseType === 'pag' || baseType === 'ipa' || baseType === 'ire' || baseType === 'pre') {
                        categories.roles.push(...targets.map(t => ({ type: relType, target: t })));
                    } else if (baseType === 'cau' || baseType === 'ent') {
                        categories.inferences.push(...targets.map(t => ({ type: relType, target: t })));
                    } else if (baseType === 'opp') {
                        categories.opposites.push(...targets.map(t => ({ type: relType, target: t })));
                    }
                }

                return categories;
            }, []);


            const loadConceptWithRelations = React.useCallback(async (conceptId) => {
                console.log('ðŸ”µ loadConceptWithRelations called for:', conceptId);

                // Load the concept data
                const conceptData = await loadConcept(conceptId); // <-- 1. CAPTURE the return value
                console.log('âœ… Concept loaded:', conceptId);

                // Load relations for this concept
                const relations = await loadConceptRelations(conceptId, conceptData); // <-- 2. PASS it in
                console.log('âœ… Relations loaded:', conceptId, relations);

                // Initialize with center node and its hypernyms
                const initialVisible = new Set([conceptId]);
                const categories = categorizeRelations(relations);
                const initialSelected = {};

                console.log('ðŸ“Š Categories:', categories);

                if (categories.hypernyms.length > 0) {
                    console.log('ðŸ”¼ Loading hypernyms:', categories.hypernyms);
                    const hypernymPromises = categories.hypernyms.map(async (rel) => {
                        initialVisible.add(rel.target);
                        const conceptData = await loadConcept(rel.target);
                        const relations = await loadConceptRelations(rel.target, conceptData);
                        return { conceptId: rel.target, relations };
                    });

                    const results = await Promise.all(hypernymPromises);
                    const updates = {};
                    results.forEach(({ conceptId, relations }) => {
                        updates[conceptId] = relations;
                    });

                    // â­ KEY FIX: Set these BEFORE setting relatedConcepts
                    console.log('ðŸŽ¯ Setting visible nodes:', initialVisible);
                    console.log('ðŸŽ¯ Setting selected categories:', initialSelected);
                    setVisibleNodes(initialVisible);
                    setSelectedCategories(initialSelected);

                    // Now set all the relations at once
                    setRelatedConcepts(prev => ({ ...prev, [conceptId]: relations, ...updates }));

                    initialSelected[conceptId] = new Set(['hypernyms']);
                } else {
                    // No hypernyms case
                    console.log('ðŸŽ¯ Setting visible nodes:', initialVisible);
                    console.log('ðŸŽ¯ Setting selected categories:', initialSelected);
                    setVisibleNodes(initialVisible);
                    setSelectedCategories(initialSelected);
                    setRelatedConcepts(prev => ({ ...prev, [conceptId]: relations }));
                }

                console.log('âœ… loadConceptWithRelations complete for:', conceptId);
            }, [loadConcept, loadConceptRelations, categorizeRelations]);


            // Save definition language preference
            useEffect(() => {
                localStorage.setItem('definitionLanguage', definitionLanguage);
            }, [definitionLanguage]);

            // Scroll to top when viewing a concept
            useEffect(() => {
                if (view === 'concept') {
                    window.scrollTo(0, 0);
                }
            }, [view, selectedConcept]);

            // Update URL when search or filters change
            useEffect(() => {
                if (!prefixMap) return;
                if (isInitialLoadRef.current) {
                    isInitialLoadRef.current = false;
                    return;
                }
                if (isPopStateRef.current) {
                    isPopStateRef.current = false;
                    return;
                }

                let newUrl;
                if (activeTab === 'python') {
                    newUrl = '#/python';
                } else if (activeTab === 'data') {
                    newUrl = '#/data';
                } else if (activeTab === 'about') {
                    newUrl = '#/about';
                } else if (activeTab === 'publications') {
                    newUrl = '#/publications';
                } else if (view === 'search') {
                    const params = new URLSearchParams();
                    if (currentSearch) params.set('q', currentSearch);
                    if (languageFilter.size > 0) params.set('lang', Array.from(languageFilter).join(','));
                    if (posFilter.size > 0) params.set('pos', Array.from(posFilter).join(','));
                    if (senseFilter) params.set('s', senseFilter);

                    const queryString = params.toString();
                    newUrl = queryString ? '#/search?' + queryString : '#/search';
                } else if (view === 'concept' && selectedConcept) {
                    const params = new URLSearchParams();
                    params.set('concept', selectedConcept);
                    newUrl = '#/search?' + params.toString();
                } else if (view === 'sense' && selectedSense) {
                    const params = new URLSearchParams();
                    params.set('sense', selectedSense);
                    newUrl = '#/search?' + params.toString();
                }

                if (newUrl && newUrl !== window.location.hash) {
                    window.history.pushState({}, '', newUrl);
                }
            }, [view, currentSearch, languageFilter, posFilter, senseFilter, selectedConcept, selectedSense, prefixMap, activeTab]);

            // Handle browser back/forward buttons
            useEffect(() => {
                const handlePopState = () => {
                    isPopStateRef.current = true;

                    const hash = window.location.hash.slice(1);
                    const [path, queryString] = hash.split('?');

                    if (path === '/python') {
                        setActiveTab('python');
                    } else if (path === '/data') {
                        setActiveTab('data');
                    } else if (path === '/about') {
                        setActiveTab('about');
                    } else if (path === '/publications') {
                        setActiveTab('publications');
                    } else {
                        setActiveTab('browser');

                        const params = new URLSearchParams(queryString || '');
                        const urlSearch = params.get('q');
                        const urlLang = params.get('lang') ? new Set(params.get('lang').split(',')) : new Set();
                        const urlPos = params.get('pos') ? new Set(params.get('pos').split(',')) : new Set();
                        const urlSense = params.get('sense');
                        const urlSenseFilter = params.get('s');
                        const urlConcept = params.get('concept');

                        setLanguageFilter(urlLang);
                        setPosFilter(urlPos);
                        setSenseFilter(urlSenseFilter);
                        setSynonymsCollapsed({});

                        if (urlConcept) {
                                setSelectedConcept(urlConcept);
                                setSelectedSense(null);
                                setView('concept');
                                loadConceptWithRelations(urlConcept);
                        } else if (urlSense) {
                            setSelectedSense(urlSense);
                            setSelectedConcept(null);
                            setView('sense');
                            loadSense(urlSense);
                        } else {
                            setView('search');
                            setSelectedConcept(null);
                            setSelectedSense(null);
                            if (urlSearch) {
                                setSearchTerm(urlSearch);
                                setCurrentSearch(urlSearch);
                                performSearchWithFilters(urlSearch, urlLang, urlPos, urlSenseFilter);
                            } else {
                                setSearchTerm('');
                                setCurrentSearch('');
                            }
                        }
                    }
                };
                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, [prefixMap, loadedSenses]);

            // Load prefix map and language codes in background
            useEffect(() => {
                const loadInitialData = async () => {
                    try {
                        // Load prefix map
                        const prefixResponse = await fetch('website_data/prefix_map.json');
                        const prefixData = await prefixResponse.json();
                        setPrefixMap(prefixData);

                        // Try to load language codes
                        try {
                            const langResponse = await fetch('website_data/lang_codes.json');
                            const langData = await langResponse.json();
                            setLangCodes(langData);
                        } catch (e) {
                            console.log('Language codes file not found, using default naming');
                        }

                        // Load all prefix lookup files to discover all languages
                        const allLangsSet = new Set();
                        const lookupFiles = new Set();

                        for (const prefix in prefixData) {
                            const files = Array.isArray(prefixData[prefix]) ? prefixData[prefix] : [prefixData[prefix]];
                            files.forEach(f => lookupFiles.add(f));
                        }

                        // Load a sample of lookup files to discover languages
                        const filesToSample = Array.from(lookupFiles).slice(0, 10);
                        for (const filename of filesToSample) {
                            try {
                                const response = await fetch(`website_data/prefix_lookups/${filename}`);
                                const data = await response.json();

                                for (const word in data) {
                                    for (const pos in data[word]) {
                                        for (const lang in data[word][pos]) {
                                            allLangsSet.add(lang);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log('Could not load', filename);
                            }
                        }

                        setAllLanguages(Array.from(allLangsSet));

                        // Handle initial URL
                        const hash = window.location.hash.slice(1);
                        const [path, queryString] = hash.split('?');

                        if (path === '/python') {
                            setActiveTab('python');
                        } else if (path === '/data') {
                            setActiveTab('data');
                        } else if (path === '/about') {
                            setActiveTab('about');
                        } else if (path === '/publications') {
                            setActiveTab('publications');
                        } else {
                            setActiveTab('browser');

                            const params = new URLSearchParams(queryString || '');
                            const urlSearch = params.get('q');
                            const urlLang = params.get('lang') ? new Set(params.get('lang').split(',')) : new Set();
                            const urlPos = params.get('pos') ? new Set(params.get('pos').split(',')) : new Set();
                            const urlSenseFilter = params.get('s');
                            const urlConcept = params.get('concept');
                            const urlSense = params.get('sense');

                            setLanguageFilter(urlLang);
                            setPosFilter(urlPos);
                            setSenseFilter(urlSenseFilter);

                            if (urlConcept) {
                                console.log('ðŸŒ Initial URL load - concept:', urlConcept);
                                setSelectedConcept(urlConcept);
                                setView('concept');
                                loadConceptWithRelations(urlConcept);
                            } else if (urlSense) {
                                setSelectedSense(urlSense);
                                setView('sense');
                                loadSense(urlSense);
                            } else if (urlSearch) {
                                setSearchTerm(urlSearch);
                                setCurrentSearch(urlSearch);
                                setView('search');
                            }
                        }
                    } catch (err) {
                        setError(err.message);
                    }
                };
                loadInitialData();
            }, []);

            // Render D3.js graph when concept relations are loaded
            useEffect(() => {
                console.log('ðŸ“ˆ Graph render effect triggered');
                console.log('  - view:', view);
                console.log('  - selectedConcept:', selectedConcept);
                console.log('  - relatedConcepts[selectedConcept]:', relatedConcepts[selectedConcept]);

                if (!visibleNodes || visibleNodes.size === 0) {
                    console.log('âŒ No visible nodes yet');
                    return;
                }

                if (view !== 'concept' || !selectedConcept || !relatedConcepts[selectedConcept]) {
                    console.log('âŒ Graph render early return');
                    return;
                }

                const concept = getConceptData(selectedConcept);
                console.log('  - concept data:', concept);
                if (!concept) {
                    console.log('âŒ No concept data, returning');
                    return;
                }

                // Check if all visible nodes have their concepts loaded
                let allConceptsLoaded = true;
                visibleNodes.forEach(nodeId => {
                    if (!getConceptData(nodeId)) {
                        console.log('âŒ Missing concept data for node:', nodeId);
                        allConceptsLoaded = false;
                    }
                });

                if (!allConceptsLoaded) {
                    console.log('âŒ Not all concepts loaded yet');
                    return;
                }

                console.log('âœ… All checks passed, rendering graph!');

                let timeoutId;
                let rafId;

                // Use requestAnimationFrame to wait for the DOM to be painted
                rafId = requestAnimationFrame(() => {
                    // Then use a small timeout for extra safety
                    timeoutId = setTimeout(() => {
                        console.log('ðŸŽ¨ Timeout fired, looking for container');
                        const container = document.getElementById('concept-graph');
                        console.log('  - container:', container);
                        if (!container) {
                            console.log('âŒ Container not found!');
                            return;
                        }

                        const width = container.clientWidth;
                        const height = 500;
                        console.log('  - width:', width, 'height:', height);

                        // --- 1. CHECK FOR FULL RESET ---
                        const isNewConcept = lastConceptRef.current !== selectedConcept;
                        console.log('  - isNewConcept:', isNewConcept);
                        console.log('  - simulationRef.current:', simulationRef.current);

                        if (isNewConcept || !simulationRef.current) {
                            console.log('ðŸ†• Creating new simulation');
                            // This is a new central concept, so nuke and pave
                            container.innerHTML = '';
                            simulationRef.current = null; // Clear old simulation
                            lastConceptRef.current = selectedConcept;

                            // --- DO ALL YOUR ONE-TIME SETUP ---
                            const svg = d3.select(container)
                                .append('svg')
                                .attr('width', width)
                                .attr('height', height)
                                .style('background', '#ffffff')
                                .style('border', '1px solid #d1d5db')
                                .style('border-radius', '0.25rem');

                            const g = svg.append('g');

                            // Store refs
                            svgRef.current = svg.node();
                            gRef.current = g.node();

                            const zoom = d3.zoom()
                                .scaleExtent([0.1, 4])
                                .on('zoom', (event) => {
                                    g.attr('transform', event.transform);
                                })
                                .on('end', (event) => {
                                    const currentHoveredId = hoveredNodeRef.current;
                                    if (currentHoveredId && simulationRef.current) {
                                        const nodeData = simulationRef.current.nodes().find(n => n.id === currentHoveredId);
                                        if (nodeData) {
                                            const transform = event.transform;
                                            const nodeSimX = nodeData.x + (nodeData.width || 200) / 2;
                                            const nodeSimY = nodeData.y - (nodeData.height || 60) / 2;
                                            const svgRelativeX = transform.applyX(nodeSimX);
                                            const svgRelativeY = transform.applyY(nodeSimY);

                                            if (setHoverMenuPositionRef.current) {
                                                setHoverMenuPositionRef.current({ x: svgRelativeX + 10, y: svgRelativeY });
                                            }
                                        }
                                    }
                                });
                            svg.call(zoom);

                            // Add defs (only do this once)
                            svg.append('defs');

                            // --- CREATE SIMULATION (but don't start it) ---
                            // Custom force to maintain edge visibility
                            function edgeVisibilityForce() {
                                const desiredVisibleLength = 150;
                                let nodes, links;

                                function force(alpha) {
                                    if (!links) return;
                                    for (const link of links) {
                                        const source = link.source;
                                        const target = link.target;

                                        const dx = target.x - source.x;
                                        const dy = target.y - source.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);

                                        if (dist < 1) continue;

                                        const nx = dx / dist;
                                        const ny = dy / dist;

                                        const sW = (source.width || 200) / 2;
                                        const sH = (source.height || 60) / 2;
                                        const tW = (target.width || 200) / 2;
                                        const tH = (target.height || 60) / 2;

                                        const sBoundary = Math.min(
                                            Math.abs(nx) > 0.001 ? sW / Math.abs(nx) : Infinity,
                                            Math.abs(ny) > 0.001 ? sH / Math.abs(ny) : Infinity
                                        );

                                        const tBoundary = Math.min(
                                            Math.abs(nx) > 0.001 ? tW / Math.abs(nx) : Infinity,
                                            Math.abs(ny) > 0.001 ? tH / Math.abs(ny) : Infinity
                                        );

                                        const desiredDist = sBoundary + tBoundary + desiredVisibleLength;
                                        const error = dist - desiredDist;

                                        const adjust = error * alpha * 1.5;
                                        const adjX = nx * adjust * 0.5;
                                        const adjY = ny * adjust * 0.5;

                                        target.x -= adjX;
                                        target.y -= adjY;
                                        source.x += adjX;
                                        source.y += adjY;
                                    }
                                }

                                force.initialize = function(_, l) {
                                    nodes = _;
                                    links = l;
                                };

                                return force;
                            }

                            // Custom rectangular collision
                            function rectCollide() {
                                let nodes;
                                const padding = 15;

                                function force(alpha) {
                                    if (!nodes) return;
                                    for (let i = 0; i < nodes.length; i++) {
                                        const node = nodes[i];
                                        const nw = (node.width || 200) / 2 + padding;
                                        const nh = (node.height || 60) / 2 + padding;

                                        for (let j = i + 1; j < nodes.length; j++) {
                                            const other = nodes[j];
                                            const ow = (other.width || 200) / 2 + padding;
                                            const oh = (other.height || 60) / 2 + padding;

                                            const dx = other.x - node.x;
                                            const dy = other.y - node.y;

                                            const xGap = Math.abs(dx) - (nw + ow);
                                            const yGap = Math.abs(dy) - (nh + oh);

                                            if (xGap < 0 && yGap < 0) {
                                                if (Math.abs(xGap) < Math.abs(yGap)) {
                                                    const push = xGap * 0.5 * alpha;
                                                    const dir = dx > 0 ? 1 : -1;
                                                    node.x += push * dir;
                                                    other.x -= push * dir;
                                                } else {
                                                    const push = yGap * 0.5 * alpha;
                                                    const dir = dy > 0 ? 1 : -1;
                                                    node.y += push * dir;
                                                    other.y -= push * dir;
                                                }
                                            }
                                        }
                                    }
                                }

                                force.initialize = function(_) {
                                    nodes = _;
                                };

                                return force;
                            }

                            const simulation = d3.forceSimulation()
                                .force('link', d3.forceLink().id(d => d.id).distance(150).strength(0.1))
                                .force('charge', d3.forceManyBody().strength(-1500))
                                .force('center', d3.forceCenter(width / 2, height / 2))
                                .force('collision', rectCollide())
                                .force('edgeLength', edgeVisibilityForce())
                                .alphaDecay(0.02)
                                .on('end', () => {
                                    simulation.stop();
                                });

                            simulation.alphaTarget(0).alphaMin(0.001);

                            simulationRef.current = simulation;

                            // --- SET THE TICK HANDLER (only do this once) ---
                            simulation.on('tick', () => {
                                const g = d3.select(gRef.current);
                                if (!g) return;

                                // Update links
                                g.selectAll('line.link-line').each(function(d) {
                                    const dx = d.target.x - d.source.x;
                                    const dy = d.target.y - d.source.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    if (dist === 0) {
                                        d3.select(this)
                                            .attr('x1', d.source.x)
                                            .attr('y1', d.source.y)
                                            .attr('x2', d.target.x)
                                            .attr('y2', d.target.y);
                                        return;
                                    }
                                    const normDx = dx / dist;
                                    const normDy = dy / dist;
                                    const sHalfWidth = (d.source.width || 200) / 2;
                                    const sHalfHeight = (d.source.height || 60) / 2;
                                    const sTimeX = normDx !== 0 ? sHalfWidth / Math.abs(normDx) : Infinity;
                                    const sTimeY = normDy !== 0 ? sHalfHeight / Math.abs(normDy) : Infinity;
                                    const sTime = Math.min(sTimeX, sTimeY);
                                    const x1 = d.source.x + normDx * sTime;
                                    const y1 = d.source.y + normDy * sTime;
                                    const tHalfWidth = (d.target.width || 200) / 2;
                                    const tHalfHeight = (d.target.height || 60) / 2;
                                    const tTimeX = normDx !== 0 ? tHalfWidth / Math.abs(normDx) : Infinity;
                                    const tTimeY = normDy !== 0 ? tHalfHeight / Math.abs(normDy) : Infinity;
                                    const tTime = Math.min(tTimeX, tTimeY);
                                    const x2 = d.target.x - normDx * tTime;
                                    const y2 = d.target.y - normDy * tTime;
                                    d3.select(this)
                                        .attr('x1', x1)
                                        .attr('y1', y1)
                                        .attr('x2', x2)
                                        .attr('y2', y2);
                                });

                                // Update link labels
                                g.selectAll('g.link-label-group').each(function(d) {
                                    const dx = d.target.x - d.source.x;
                                    const dy = d.target.y - d.source.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist === 0) return;
                                    const normDx = dx / dist;
                                    const normDy = dy / dist;
                                    const sHalfWidth = (d.source.width || 200) / 2;
                                    const sHalfHeight = (d.source.height || 60) / 2;
                                    const sTimeX = normDx !== 0 ? sHalfWidth / Math.abs(normDx) : Infinity;
                                    const sTimeY = normDy !== 0 ? sHalfHeight / Math.abs(normDy) : Infinity;
                                    const sTime = Math.min(sTimeX, sTimeY);
                                    const x1 = d.source.x + normDx * sTime;
                                    const y1 = d.source.y + normDy * sTime;
                                    const tHalfWidth = (d.target.width || 200) / 2;
                                    const tHalfHeight = (d.target.height || 60) / 2;
                                    const tTimeX = normDx !== 0 ? tHalfWidth / Math.abs(normDx) : Infinity;
                                    const tTimeY = normDy !== 0 ? tHalfHeight / Math.abs(normDy) : Infinity;
                                    const tTime = Math.min(tTimeX, tTimeY);
                                    const x2 = d.target.x - normDx * tTime;
                                    const y2 = d.target.y - normDy * tTime;
                                    const midX = (x1 + x2) / 2;
                                    const midY = (y1 + y2) / 2;
                                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                                    const displayAngle = (angle > 90 || angle < -90) ? angle + 180 : angle;
                                    d3.select(this)
                                        .attr('transform', `translate(${midX}, ${midY}) rotate(${displayAngle})`);
                                    const text = d3.select(this).select('text');
                                    text.attr('x', 0).attr('y', 0);
                                    const bbox = text.node().getBBox();
                                    const padding = 3;
                                    d3.select(this).select('rect')
                                        .attr('x', bbox.x - padding)
                                        .attr('y', bbox.y - padding)
                                        .attr('width', bbox.width + padding * 2)
                                        .attr('height', bbox.height + padding * 2);
                                });

                                // Update nodes
                                g.selectAll('g.node-group')
                                    .attr('transform', d => {
                                        const offsetX = (d.width || 200) / 2;
                                        const offsetY = (d.height || 60) / 2;
                                        return `translate(${d.x - offsetX},${d.y - offsetY})`;
                                    });
                            });
                        }

                        // --- 2. GET PERSISTED ELEMENTS ---
                        const g = d3.select(gRef.current);
                        const simulation = simulationRef.current;
                        const defs = d3.select(svgRef.current).select('defs');

                        // --- 3. CALCULATE DATA (FIXED LOGIC) ---
                        const nodesArray = [];
                        const linksArray = [];
                        const linkSet = new Set();

                        // 3a. Build Nodes Array
                        visibleNodes.forEach(nodeId => {
                            const concept = getConceptData(nodeId);
                            if (!concept) return;

                            const nodeDef = concept.d?.en || concept.d?.[Object.keys(concept.d)[0]] || '(No definition)';

                            const existingNode = simulation.nodes().find(n => n.id === nodeId);

                            const nodeData = {
                                id: nodeId,
                                label: `${getPosName(concept.oc)}. ${nodeDef}`,
                                pos: getPosName(concept.oc) + '.',
                                definition: nodeDef,
                                isCenter: nodeId === selectedConcept
                            };

                            if (existingNode) {
                                nodeData.x = existingNode.x;
                                nodeData.y = existingNode.y;
                                nodeData.width = existingNode.width;
                                nodeData.height = existingNode.height;
                            } else {
                                const isInitialLoad = !simulationRef.current || simulationRef.current.nodes().length === 0;

                                if (isInitialLoad) {
                                    nodeData.x = width / 2;
                                    nodeData.y = nodeData.isCenter ? (height / 2) + (0.01 * height) : (height / 2) - (0.01 * height);
                                } else {
                                    const existingNodes = simulation.nodes();
                                    let sourceNode = null;

                                    for (let i = 0; i < existingNodes.length; i++) {
                                        const existing = existingNodes[i];
                                        const rels = relatedConcepts[existing.id];
                                        if (!rels) continue;

                                        for (const relType in rels) {
                                            if (rels[relType].includes(nodeId)) {
                                                sourceNode = existing;
                                                break;
                                            }
                                        }
                                        if (sourceNode) break;
                                    }

                                    if (sourceNode) {
                                        nodeData.x = sourceNode.x + (Math.random() - 0.5) * 20;
                                        nodeData.y = sourceNode.y + (Math.random() - 0.5) * 20;
                                    } else {
                                        nodeData.x = width / 2;
                                        nodeData.y = height / 4;
                                    }
                                }
                            }

                            nodesArray.push(nodeData);
                        });

                        // 3b. Build Links Array
                        nodesArray.forEach(node => {
                            const nodeId = node.id;
                            const relations = relatedConcepts[nodeId];
                            if (!relations) return;

                            for (const relType in relations) {
                                const targets = relations[relType];
                                const isInverse = relType.startsWith('-');
                                const baseRelType = isInverse ? relType.substring(1) : relType;
                                const displayRelType = relationNames[baseRelType] || baseRelType;
                                const edgeColor = relationColors[baseRelType] || '#9ca3af';

                                for (const targetId of targets) {
                                    if (visibleNodes.has(targetId)) {
                                        const sourceId = isInverse ? targetId : nodeId;
                                        const targetIdActual = isInverse ? nodeId : targetId;

                                        const linkKey = `${sourceId}-${targetIdActual}-${baseRelType}`;
                                        if (linkSet.has(linkKey)) continue;
                                        linkSet.add(linkKey);

                                        linksArray.push({
                                            source: sourceId,
                                            target: targetIdActual,
                                            label: displayRelType,
                                            color: edgeColor,
                                            isInverse: isInverse
                                        });
                                    }
                                }
                            }
                        });

                        // --- 4. UPDATE D3 WITH D3.JOIN ---

                        // Update markers
                        const uniqueColors = [...new Set(linksArray.map(l => l.color))];
                        defs.selectAll('marker')
                            .data(uniqueColors, d => d)
                            .join(
                                enter => enter.append('marker')
                                    .attr('id', d => `arrow-${d.replace('#', '')}`)
                                    .attr('viewBox', '0 -5 10 10')
                                    .attr('refX', 9)
                                    .attr('refY', 0)
                                    .attr('markerWidth', 6)
                                    .attr('markerHeight', 6)
                                    .attr('orient', 'auto')
                                    .append('path')
                                    .attr('d', 'M0,-5L10,0L0,5')
                                    .attr('fill', d => d),
                                update => update,
                                exit => exit.remove()
                            );

                        // Update links
                        g.selectAll('line.link-line')
                            .data(linksArray, d => `${d.source.id || d.source}-${d.target.id || d.target}-${d.label}`)
                            .join(
                                enter => enter.append('line')
                                    .attr('class', 'link-line')
                                    .attr('stroke', d => d.color)
                                    .attr('stroke-width', 2),
                                update => update
                                    .attr('stroke', d => d.color),
                                exit => exit.remove()
                            )
                            .attr('marker-end', d => `url(#arrow-${d.color.replace('#', '')})`);

                        // Update link labels
                        const linkLabel = g.selectAll('g.link-label-group')
                            .data(linksArray, d => `${d.source.id || d.source}-${d.target.id || d.target}-${d.label}`)
                            .join(
                                enter => {
                                    const g = enter.append('g').attr('class', 'link-label-group');
                                    g.append('rect')
                                        .attr('fill', 'white')
                                        .attr('stroke', 'none')
                                        .attr('rx', 2);
                                    g.append('text')
                                        .attr('font-size', 11)
                                        .attr('font-weight', 'normal')
                                        .attr('text-anchor', 'middle')
                                        .attr('dominant-baseline', 'middle');
                                    return g;
                                },
                                update => update,
                                exit => exit.remove()
                            );

                        linkLabel.select('text')
                            .attr('fill', d => d.color)
                            .text(d => d.label);

                        // Drag functions
                        function dragstarted(event, d) {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        }

                        function dragged(event, d) {
                            d.fx = event.x;
                            d.fy = event.y;
                        }

                        function dragended(event, d) {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        }

                        // Update nodes
                        const node = g.selectAll('g.node-group')
                            .data(nodesArray, d => d.id)
                            .join(
                                enter => {
                                    const nodeGroup = enter.append('g')
                                        .attr('class', 'node-group')
                                        .style('cursor', 'pointer')
                                        .on('click', (event, d) => {
                                            if (d.id !== selectedConcept) {
                                                handleConceptClick(d.id);
                                            }
                                        })
                                        .on('mouseenter', function(event, d) {
                                            if (hoverTimeoutRef.current) {
                                                clearTimeout(hoverTimeoutRef.current);
                                                hoverTimeoutRef.current = null;
                                            }

                                            d3.select(this).select('rect')
                                                .attr('stroke', '#3b82f6')
                                                .attr('stroke-width', 2);

                                            if (hoveredNodeRef.current !== d.id) {
                                                const svgNode = svgRef.current;
                                                if (!svgNode) return;

                                                const transform = d3.zoomTransform(svgNode);
                                                const nodeSimX = d.x + (d.width || 200) / 2;
                                                const nodeSimY = d.y - (d.height || 60) / 2;
                                                const svgRelativeX = transform.applyX(nodeSimX);
                                                const svgRelativeY = transform.applyY(nodeSimY);

                                                setHoveredNode(d.id);
                                                setHoverMenuPosition({
                                                    x: svgRelativeX + 10,
                                                    y: svgRelativeY
                                                });
                                            }
                                        })
                                        .on('mouseleave', function(event, d) {
                                            d3.select(this).select('rect')
                                                .attr('stroke', d.isCenter ? '#000000' : '#d1d5db')
                                                .attr('stroke-width', d.isCenter ? 2 : 1);
                                            hoverTimeoutRef.current = setTimeout(() => {
                                                setHoveredNode(null);
                                                setHoverMenuPosition(null);
                                            }, 300);
                                        })
                                        .call(d3.drag()
                                            .on('start', dragstarted)
                                            .on('drag', dragged)
                                            .on('end', dragended));

                                    nodeGroup.each(function(d) {
                                        const nodeGroup = d3.select(this);
                                        const cache = nodeSizeCache.current;
                                        const cacheKey = `${d.id}-${d.definition}-${d.isCenter}`;

                                        let cachedSize = cache.get(cacheKey);

                                        if (!cachedSize) {
                                            const fontSize = d.isCenter ? 15 : 14;
                                            const avgCharWidth = fontSize * 0.5;
                                            const posWidth = d.pos.length * avgCharWidth * 1.1;

                                            const maxWidth = 250;
                                            const words = d.definition.split(' ');
                                            let lines = [];
                                            let currentLine = [];
                                            let currentWidth = posWidth + 4;

                                            words.forEach((word) => {
                                                const wordWidth = word.length * avgCharWidth;
                                                if (currentWidth + wordWidth > maxWidth && currentLine.length > 0) {
                                                    lines.push(currentLine.join(' '));
                                                    currentLine = [word];
                                                    currentWidth = wordWidth;
                                                } else {
                                                    currentLine.push(word);
                                                    currentWidth += wordWidth + (avgCharWidth * 0.3);
                                                }
                                            });
                                            if (currentLine.length > 0) {
                                                lines.push(currentLine.join(' '));
                                            }

                                            const padding = 12;
                                            const lineHeight = d.isCenter ? 18 : 17;
                                            const boxWidth = maxWidth + padding * 2;
                                            const boxHeight = lines.length * lineHeight + padding * 2;

                                            cachedSize = { boxWidth, boxHeight, lineHeight, posWidth, lines };
                                            addToCache(cacheKey, cachedSize);
                                        }

                                        const { boxWidth, boxHeight, lineHeight, posWidth, lines } = cachedSize;

                                        nodeGroup.append('rect')
                                            .attr('width', boxWidth)
                                            .attr('height', boxHeight)
                                            .attr('x', 0)
                                            .attr('y', 0)
                                            .attr('fill', '#ffffff')
                                            .attr('rx', 3);
                                        const textGroup = nodeGroup.append('g')
                                            .attr('transform', `translate(12, 12)`);
                                        const firstLineY = lineHeight * 0.75;
                                        textGroup.append('text')
                                            .attr('x', 0)
                                            .attr('y', firstLineY)
                                            .attr('font-size', d.isCenter ? 15 : 14)
                                            .attr('font-style', 'italic')
                                            .attr('text-anchor', 'start')
                                            .text(d.pos);
                                        if (lines.length > 0) {
                                            textGroup.append('text')
                                                .attr('x', posWidth + 4)
                                                .attr('y', firstLineY)
                                                .attr('font-size', d.isCenter ? 15 : 14)
                                                .attr('text-anchor', 'start')
                                                .text(lines[0]);
                                        }
                                        for (let i = 1; i < lines.length; i++) {
                                            textGroup.append('text')
                                                .attr('x', 0)
                                                .attr('y', firstLineY + i * lineHeight)
                                                .attr('font-size', d.isCenter ? 15 : 14)
                                                .attr('text-anchor', 'start')
                                                .text(lines[i]);
                                        }

                                        d.width = boxWidth;
                                        d.height = boxHeight;
                                    });

                                    return nodeGroup;
                                },
                                update => update,
                                exit => exit.remove()
                            );

                        node.select('rect')
                            .attr('stroke', d => d.isCenter ? '#000000' : '#d1d5db')
                            .attr('stroke-width', d => d.isCenter ? 2 : 1);

                        // --- 5. UPDATE AND RESTART SIMULATION ---
                        simulation.nodes(nodesArray);
                        simulation.force('link').links(linksArray);
                        simulation.force('edgeLength').initialize(nodesArray, linksArray);
                        simulation.alpha(isNewConcept ? 0.3 : 0.1).restart();

                    }, 50);
                });

                // Cleanup function
                return () => {
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                };
            }, [selectedConcept, relatedConcepts, view, visibleNodes]);

            // Perform initial search once prefixMap is loaded
            useEffect(() => {
                if (prefixMap && currentSearch && view === 'search' && Object.keys(loadedSenses).length === 0) {
                    performSearchWithFilters(currentSearch, languageFilter, posFilter, senseFilter);
                }
            }, [prefixMap, currentSearch]);

            useEffect(() => {
                return () => {
                    // Cleanup when component unmounts
                    if (simulationRef.current) {
                        simulationRef.current.stop();
                    }
                    nodeSizeCache.current.clear();
                };
            }, []);

            // Check if mouse is already over menu when it appears
            useEffect(() => {
                if (hoverMenuPosition && menuRef.current) {
                    const checkHover = () => {
                        const rect = menuRef.current.getBoundingClientRect();
                        const mouseX = window.event?.clientX;
                        const mouseY = window.event?.clientY;

                        if (mouseX && mouseY) {
                            const isOver = mouseX >= rect.left && mouseX <= rect.right &&
                                          mouseY >= rect.top && mouseY <= rect.bottom;

                            if (isOver && hoverTimeoutRef.current) {
                                clearTimeout(hoverTimeoutRef.current);
                                hoverTimeoutRef.current = null;
                            }
                        }
                    };

                    // Check immediately and after a brief delay for rendering
                    setTimeout(checkHover, 0);
                    setTimeout(checkHover, 50);
                }
            }, [hoverMenuPosition]);

            const loadPrefixLookup = async (filename) => {
                if (loadedPrefixLookups[filename]) {
                    return loadedPrefixLookups[filename];
                }

                try {
                    const response = await fetch(`website_data/prefix_lookups/${filename}`);
                    const data = await response.json();
                    setLoadedPrefixLookups(prev => ({ ...prev, [filename]: data }));
                    return data;
                } catch (err) {
                    console.error('Error loading prefix lookup:', err);
                    return null;
                }
            };
            const performSearchWithFilters = async (term, lang, pos, sense) => {
                if (!term.trim() || !prefixMap) return;

                setLoadingResults(true);

                const searchLower = remove_accents(term.toLowerCase());
                const prefix = getPrefix(searchLower);

                // Get lookup files for this prefix
                const lookupFiles = prefixMap[prefix];
                if (!lookupFiles) {
                    setLoadingResults(false);
                    return;
                }

                // Normalize to array
                const files = Array.isArray(lookupFiles) ? lookupFiles : [lookupFiles];

                // Load all prefix lookup files and collect sense IDs with metadata
                const senseIdsWithMeta = [];

                for (const filename of files) {
                    const lookupData = await loadPrefixLookup(filename);
                    if (!lookupData || !lookupData[searchLower]) continue;

                    const wordformData = lookupData[searchLower];

                    for (const posCode in wordformData) {
                        if (pos.size > 0 && !pos.has(posCode)) continue;

                        for (const langCode in wordformData[posCode]) {
                            if (lang.size > 0 && !lang.has(langCode)) continue;

                            // Store each sense ID with its metadata from prefix lookup
                            wordformData[posCode][langCode].forEach(senseId => {
                                senseIdsWithMeta.push({
                                    id: senseId.toString(),
                                    lg: langCode,
                                    ontological_category: posCode,
                                    l: searchLower  // We know this matches the search term
                                });
                            });
                        }
                    }
                }

                // Immediately show skeleton results with basic info
                const skeletonSenses = {};
                senseIdsWithMeta.forEach(meta => {
                    skeletonSenses[meta.id] = meta;
                });

                setLoadedSenses(prev => ({ ...prev, ...skeletonSenses }));
                setLoadingResults(false);

                if (sense) {
                    setSynonymsCollapsed(prev => ({ ...prev, [sense]: false }));
                }

                // Now load full sense data in the background
                for (const meta of senseIdsWithMeta) {
                    loadSense(meta.id).then(senseData => {
                        if (senseData) {
                            setLoadedSenses(prev => ({ ...prev, [meta.id]: senseData }));
                        }
                    });
                }
            };
            const performSearchWithTerm = async (term) => {
                await performSearchWithFilters(term, languageFilter, posFilter, senseFilter);
            };

            const performSearch = async () => {
                if (!searchTerm.trim() || !prefixMap) return;
                const term = searchTerm.trim();
                setCurrentSearch(term);
                setSenseFilter(null);
                setSynonymsCollapsed({});
                await performSearchWithFilters(term, languageFilter, posFilter, null);
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    performSearch();
                }
            };

            const getFilteredWordforms = () => {
                if (!currentSearch) return [];

                const results = [];

                for (const senseId in loadedSenses) {
                    const sense = loadedSenses[senseId];
                    if (!sense) continue;

                    // Apply sense filter
                    if (senseFilter && senseId !== senseFilter) continue;

                    // Check if this sense matches the search term
                    const lemma = sense.l ? remove_accents(sense.l.toLowerCase()) : '';
                    const searchLower = remove_accents(currentSearch.toLowerCase());

                    if (lemma === searchLower || sense.v?.some(v => remove_accents(v.toLowerCase()) === searchLower)) {
                        // Apply filters
                        const lang = sense.lg;
                        if (languageFilter.size > 0 && !languageFilter.has(lang)) continue;

                        // Get POS from concept
                        const conceptId = sense.c?.toString();
                        const concept = conceptId ? getConceptData(conceptId) : null;
                        const pos = concept?.oc || 'UNK';

                        if (posFilter.size > 0 && !posFilter.has(pos)) continue;

                        results.push({
                            ...sense,
                            id: senseId,
                            ontological_category: pos
                        });
                    }
                }

                return results;
            };

            const getAvailableCategories = (conceptId) => {
                const relations = relatedConcepts[conceptId];
                if (!relations) return [];

                const categories = categorizeRelations(relations);
                const available = [];

                if (categories.hypernyms.length > 0) available.push('hypernyms');
                if (categories.hyponyms.length > 0) available.push('hyponyms');
                if (categories.meronyms.length > 0) available.push('meronyms');
                if (categories.holonyms.length > 0) available.push('holonyms');
                if (categories.roles.length > 0) available.push('roles');
                if (categories.inferences.length > 0) available.push('inferences');
                if (categories.opposites.length > 0) available.push('opposites');

                return available;
            };

            const handleCategorySelect = (conceptId, category) => {
                const relations = relatedConcepts[conceptId];
                if (!relations) return;

                // Prevent multiple simultaneous operations
                if (isLoadingRelationsRef.current) return;

                // 1. Update selectedCategories
                const newSelectedCategories = {...selectedCategories};
                if (!newSelectedCategories[conceptId]) {
                    newSelectedCategories[conceptId] = new Set();
                } else {
                    newSelectedCategories[conceptId] = new Set(newSelectedCategories[conceptId]);
                }

                // Toggle the category
                if (newSelectedCategories[conceptId].has(category)) {
                    newSelectedCategories[conceptId].delete(category);
                    if (newSelectedCategories[conceptId].size === 0) {
                        delete newSelectedCategories[conceptId];
                    }
                } else {
                    newSelectedCategories[conceptId].add(category);
                }

                // 2. Recalculate all visible nodes from scratch using graph traversal
                const newVisibleNodes = new Set([selectedConcept]);
                const queue = [selectedConcept];
                const processed = new Set();

                while (queue.length > 0) {
                    const currentId = queue.shift();
                    if (processed.has(currentId)) continue;
                    processed.add(currentId);

                    const catsForNode = newSelectedCategories[currentId];
                    if (!catsForNode || catsForNode.size === 0) continue;

                    const relationsForNode = relatedConcepts[currentId];
                    if (!relationsForNode) continue;

                    const categorizedRels = categorizeRelations(relationsForNode);

                    catsForNode.forEach(cat => {
                        if (categorizedRels[cat]) {
                            categorizedRels[cat].forEach(rel => {
                                const targetId = rel.target;
                                if (!newVisibleNodes.has(targetId)) {
                                    newVisibleNodes.add(targetId);
                                    queue.push(targetId);
                                }
                            });
                        }
                    });
                }

                // 3. Update state immediately for fast feedback
                setSelectedCategories(newSelectedCategories);
                setVisibleNodes(newVisibleNodes);

                // 4. Pause simulation to prevent jittery layout during loading
                if (simulationRef.current) {
                    simulationRef.current.stop();
                }

                // 5. Load missing data in background
                const nodesToLoad = Array.from(newVisibleNodes).filter(
                    nodeId => !relatedConcepts[nodeId]
                );

                if (nodesToLoad.length > 0) {
                    isLoadingRelationsRef.current = true;

                    Promise.all(nodesToLoad.map(async (nodeId) => {
                        const conceptData = await loadConcept(nodeId);
                        const relations = await loadConceptRelations(nodeId, conceptData);
                        return {nodeId, relations};
                    }))
                    .then(results => {
                        const updates = {};
                        results.forEach(({nodeId, relations}) => {
                            updates[nodeId] = relations;
                        });
                        setRelatedConcepts(prev => ({...prev, ...updates}));
                        isLoadingRelationsRef.current = false;

                        // Restart simulation after all data is loaded
                        if (simulationRef.current) {
                            simulationRef.current.alpha(0.2).restart();
                        }
                    });
                }
            };

            const loadSense = async (senseId) => {
                const chunkPath = getChunkPath(parseInt(senseId), 'senses');

                if (loadedSenseChunks[chunkPath]?.[senseId]) {
                    const senseData = loadedSenseChunks[chunkPath][senseId];
                    setLoadedSenses(prev => ({ ...prev, [senseId]: senseData }));
                    return senseData;
                }

                try {
                    let chunkData = loadedSenseChunks[chunkPath];

                    if (!chunkData) {
                        const response = await fetch(chunkPath);
                        chunkData = await response.json();
                        setLoadedSenseChunks(prev => ({ ...prev, [chunkPath]: chunkData }));
                    }

                    const senseData = chunkData?.[senseId];
                    if (senseData) {
                        setLoadedSenses(prev => ({ ...prev, [senseId]: senseData }));
                    }
                    return senseData;
                } catch (err) {
                    console.error('Error loading sense:', err);
                    return null;
                }
            };
            const handleConceptClick = async (conceptId) => {
                nodeSizeCache.current.clear();

                setSelectedConcept(conceptId);
                setSelectedSense(null);
                setView('concept');
                setSynonymsCollapsed({});

                await loadConceptWithRelations(conceptId);
            };

            const handleSenseClick = async (senseId) => {
                setSelectedSense(senseId);
                setSelectedConcept(null);
                setView('sense');
                setSynonymsCollapsed({});
                await loadSense(senseId);
            };

            const handleWordformClick = (form) => {
                setSearchTerm(form);
                setCurrentSearch(form);
                setView('search');
                setSenseFilter(null);
                setSynonymsCollapsed({});
                performSearchWithTerm(form);
            };

            const handleWordformClickWithSense = (form, senseId) => {
                setSearchTerm(form);
                setCurrentSearch(form);
                setView('search');
                setSenseFilter(senseId);
                setSynonymsCollapsed({});
                setLanguageFilter(new Set());
                setPosFilter(new Set());
                performSearchWithFilters(form, new Set(), new Set(), senseId);
            };

            const handleSynonymClick = (form) => {
                setSearchTerm(form);
                setView('search');
                setCurrentSearch(form);
                setSenseFilter(null);
                setSynonymsCollapsed({});
                setTimeout(() => performSearchWithTerm(form), 0);
            };

            const handleBackToSearch = () => {
                setView('search');
                setSelectedConcept(null);
                setSelectedSense(null);
                setSynonymsCollapsed({});
            };

            const handleLogoClick = () => {
                setSearchTerm('');
                setCurrentSearch('');
                setView('search');
                setSelectedConcept(null);
                setSelectedSense(null);
                setLanguageFilter(new Set());
                setPosFilter(new Set());
                setSenseFilter(null);
                setLoadedSenses({});
                setSynonymsCollapsed({});
                setActiveTab('browser');
            };

            const renderExample = (exampleHtml) => {
                const div = document.createElement('div');
                div.innerHTML = exampleHtml;

                const parts = [];
                div.childNodes.forEach((node, idx) => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        if (node.textContent) parts.push(<span key={idx}>{node.textContent}</span>);
                    } else if (node.nodeName === 'B') {
                        parts.push(<strong key={idx}>{node.textContent}</strong>);
                    }
                });

                return parts;
            };

            const renderDefinitionWithLinks = (definitionText, annotations) => {
                if (!annotations || annotations.length === 0) {
                    return definitionText;
                }

                // Preload all senses referenced in annotations
                annotations.forEach(ann => {
                    if (!loadedSenses[ann.s.toString()]) {
                        loadSense(ann.s.toString());
                    }
                });

                const parts = [];
                let lastIndex = 0;

                // Sort annotations by start offset
                const sortedAnnotations = [...annotations].sort((a, b) => a.so - b.so);

                sortedAnnotations.forEach((ann, idx) => {
                    // Add text before this annotation
                    if (ann.so > lastIndex) {
                        parts.push(
                            <span key={`text-${idx}`}>
                                {definitionText.substring(lastIndex, ann.so)}
                            </span>
                        );
                    }

                    // Add the linked annotation
                    const annotatedText = definitionText.substring(ann.so, ann.eo);
                    const linkedSense = loadedSenses[ann.s.toString()];

                    // Only make it clickable if the sense is loaded
                    if (linkedSense?.l) {
                        parts.push(
                            <button
                                key={`link-${idx}`}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleWordformClickWithSense(linkedSense.l, ann.s.toString());
                                }}
                                className="text-blue-600 hover:underline cursor-pointer"
                            >
                                {annotatedText}
                            </button>
                        );
                    } else {
                        // Show as blue but not yet clickable (still loading)
                        parts.push(
                            <span key={`link-${idx}`} className="text-blue-600">
                                {annotatedText}
                            </span>
                        );
                    }

                    lastIndex = ann.eo;
                });

                // Add remaining text after last annotation
                if (lastIndex < definitionText.length) {
                    parts.push(
                        <span key="text-end">
                            {definitionText.substring(lastIndex)}
                        </span>
                    );
                }

                return parts;
            };

            const allPosValues = ['NOUN', 'VERB', 'ADJ', 'ADV', 'CONJ', 'ADP', 'NREF', 'UNK'];

            if (error) {
                return (
                    <div className="min-h-screen bg-white flex items-center justify-center p-4">
                        <div className="max-w-md">
                            <h2 className="font-bold text-xl mb-2">Error Loading Dictionary</h2>
                            <p className="mb-4">{error}</p>
                            <p className="text-sm text-gray-600">
                                Make sure the website_data folder is in the same directory as this HTML file.
                            </p>
                        </div>
                    </div>
                );
            }

            // Group results by language and then by POS
            const filteredResults = getFilteredWordforms();

            const groupedByLanguageAndPos = {};
            filteredResults.forEach(sense => {
                const lang = sense.lg;
                const conceptId = sense.c?.toString();
                const concept = conceptId ? getConceptData(conceptId) : null;
                const pos = concept?.oc || sense.ontological_category || 'UNK';

                if (!groupedByLanguageAndPos[lang]) {
                    groupedByLanguageAndPos[lang] = {};
                }
                if (!groupedByLanguageAndPos[lang][pos]) {
                    groupedByLanguageAndPos[lang][pos] = [];
                }

                // Group by concept
                const existing = groupedByLanguageAndPos[lang][pos].find(g => g.conceptId === conceptId);
                if (existing) {
                    existing.senses.push(sense);
                } else {
                    groupedByLanguageAndPos[lang][pos].push({
                        conceptId: conceptId,
                        senses: [sense]
                    });
                }
            });

            // Load concepts for visible results
            Object.values(groupedByLanguageAndPos).forEach(posByLang => {
                Object.values(posByLang).forEach(groups => {
                    groups.forEach(group => {
                        if (group.conceptId && !getConceptData(group.conceptId)) {
                            loadConcept(group.conceptId);
                        }
                    });
                });
            });

            return (
                <div className="min-h-screen bg-gray-50 flex flex-col">
                    <header className="bg-white border-b border-gray-200 sticky top-0 z-10">
                        <div className="max-w-4xl mx-auto px-4 py-3">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <button onClick={handleLogoClick} className="text-left hover:opacity-80 flex items-center gap-1.5">
                                        <h1 className="text-4xl -mt-0.5">ðŸ¦¢</h1>
                                        <h1 className="text-3xl font-bold text-gray-800"> Cygnet</h1>
                                    </button>
                                    <div className="flex items-center justify-between gap-1">
                                        <p className="text-sm text-gray-600 mt-1">
                                            by
                                        </p>
                                        <a
                                            href="https://omwn.org/"
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className="inline-block hover:opacity-80"
                                        >
                                            <p className="text-sm text-gray-600 mt-1">
                                                Open Multilingual Wordnet
                                            </p>
                                        </a>
                                    </div>
                                </div>
                                <a
                                    href="https://www.culturelab.psl.eu/"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="inline-block hover:opacity-80"
                                >
                                    <img
                                        src="website_data/culturelab-cropped.svg"
                                        alt="Culture Lab"
                                        className="h-6 inline-block"
                                    />
                                </a>
                            </div>
                            <nav className="flex gap-3 mt-3 -mb-3">
                                <button
                                    onClick={() => setActiveTab('browser')}
                                    className={`px-4 py-2 rounded-t-lg border-b-2 transition-colors ${activeTab === 'browser' ? 'bg-gray-50 border-blue-500 text-blue-700 font-medium' : 'border-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-50'}`}
                                >
                                    Browser
                                </button>
                                <button
                                    onClick={() => setActiveTab('python')}
                                    className={`px-4 py-2 rounded-t-lg border-b-2 transition-colors ${activeTab === 'python' ? 'bg-gray-50 border-blue-500 text-blue-700 font-medium' : 'border-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-50'}`}
                                >
                                    Python
                                </button>
                                <button
                                    onClick={() => setActiveTab('data')}
                                    className={`px-4 py-2 rounded-t-lg border-b-2 transition-colors ${activeTab === 'data' ? 'bg-gray-50 border-blue-500 text-blue-700 font-medium' : 'border-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-50'}`}
                                >
                                    Data
                                </button>
                                <button
                                    onClick={() => setActiveTab('about')}
                                    className={`px-4 py-2 rounded-t-lg border-b-2 transition-colors ${activeTab === 'about' ? 'bg-gray-50 border-blue-500 text-blue-700 font-medium' : 'border-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-50'}`}
                                >
                                    About
                                </button>
                                <button
                                    onClick={() => setActiveTab('publications')}
                                    className={`px-4 py-2 rounded-t-lg border-b-2 transition-colors ${activeTab === 'publications' ? 'bg-gray-50 border-blue-500 text-blue-700 font-medium' : 'border-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-50'}`}
                                >
                                    Publications
                                </button>
                            </nav>
                        </div>
                    </header>
                    <main className="w-full max-w-4xl mx-auto px-4 pt-6 pb-4 flex-grow">
                        {activeTab === 'browser' && (
                            <div>
                                {view === 'search' && (
                                    <div className="mb-8">
                                        {!senseFilter && (
                                            <input
                                                type="text"
                                                value={searchTerm}
                                                onChange={(e) => setSearchTerm(e.target.value)}
                                                onKeyPress={handleKeyPress}
                                                placeholder="Search for a word..."
                                                className="w-full px-3 py-2 border border-gray-300 rounded"
                                            />
                                        )}

                                        {!senseFilter && currentSearch && allLanguages.length > 0 && (
                                            <div className="mt-4 space-y-4">
                                                <div>
                                                    <label className="text-sm text-gray-600 font-semibold block mb-2">Definition Language</label>
                                                    <select
                                                        value={definitionLanguage}
                                                        onChange={(e) => setDefinitionLanguage(e.target.value)}
                                                        className="px-3 py-1 border border-gray-300 rounded text-sm"
                                                    >
                                                        <option value="en">English (default)</option>
                                                        {allLanguages
                                                            .filter(lang => lang !== 'en')
                                                            .sort((a, b) => getLangName(a).localeCompare(getLangName(b)))
                                                            .map(lang => (
                                                                <option key={lang} value={lang}>{getLangName(lang)}</option>
                                                            ))}
                                                    </select>
                                                </div>

                                                <div className="flex items-center gap-3 mb-2">
                                                    <label className="text-sm text-gray-600 font-semibold">Filter by Language</label>
                                                    <button
                                                        onClick={() => {
                                                            setLanguageFilter(new Set());
                                                            performSearchWithFilters(currentSearch, new Set(), posFilter, senseFilter);
                                                        }}
                                                        className="text-xs text-blue-600 hover:underline"
                                                    >
                                                        Clear
                                                    </button>
                                                </div>
                                                <div className="flex flex-wrap gap-3">
                                                    {allLanguages
                                                        .sort((a, b) => getLangName(a).localeCompare(getLangName(b)))
                                                        .map(lang => (
                                                        <label key={lang} className="flex items-center gap-1 cursor-pointer">
                                                            <input
                                                                type="checkbox"
                                                                checked={languageFilter.has(lang)}
                                                                onChange={() => {
                                                                    const newFilter = new Set(languageFilter);
                                                                    if (newFilter.has(lang)) {
                                                                        newFilter.delete(lang);
                                                                    } else {
                                                                        newFilter.add(lang);
                                                                    }
                                                                    setLanguageFilter(newFilter);
                                                                    setSenseFilter(null);
                                                                    performSearchWithFilters(currentSearch, newFilter, posFilter, null);
                                                                }}
                                                                className="cursor-pointer"
                                                            />
                                                            <span className="text-sm">{getLangName(lang)}</span>
                                                        </label>
                                                    ))}
                                                </div>

                                                <div className="flex items-center gap-3 mb-2">
                                                    <label className="text-sm text-gray-600 font-semibold">Filter by Part of Speech</label>
                                                    <button
                                                        onClick={() => {
                                                            setPosFilter(new Set());
                                                            performSearchWithFilters(currentSearch, languageFilter, new Set(), senseFilter);
                                                        }}
                                                        className="text-xs text-blue-600 hover:underline"
                                                    >
                                                        Clear
                                                    </button>
                                                </div>
                                                <div className="flex flex-wrap gap-3">
                                                    {allPosValues.map(pos => (
                                                        <label key={pos} className="flex items-center gap-1 cursor-pointer">
                                                            <input
                                                                type="checkbox"
                                                                checked={posFilter.has(pos)}
                                                                onChange={() => {
                                                                    const newFilter = new Set(posFilter);
                                                                    if (newFilter.has(pos)) {
                                                                        newFilter.delete(pos);
                                                                    } else {
                                                                        newFilter.add(pos);
                                                                    }
                                                                    setPosFilter(newFilter);
                                                                    setSenseFilter(null);
                                                                    performSearchWithFilters(currentSearch, languageFilter, newFilter, null);
                                                                }}
                                                                className="cursor-pointer"
                                                            />
                                                            <span className="text-sm">{getPosName(pos, true)}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {senseFilter && (
                                            <div className="mb-4 bg-blue-50 border border-blue-200 rounded p-4">
                                                <div className="flex items-center justify-between">
                                                    <span className="text-base text-gray-700">Filtered to a single sense</span>
                                                    <button
                                                        onClick={() => {
                                                            setSenseFilter(null);
                                                            performSearchWithFilters(currentSearch, languageFilter, posFilter, null);
                                                        }}
                                                        className="text-sm text-blue-600 hover:underline font-medium"
                                                    >
                                                        Clear filter
                                                    </button>
                                                </div>
                                            </div>
                                        )}

                                        {loadingResults && (
                                            <div className="text-center py-8">
                                                <p className="text-gray-600">Searching...</p>
                                            </div>
                                        )}

                                        {!loadingResults && currentSearch && filteredResults.length === 0 && (
                                            <div className="text-center py-8">
                                                <p className="text-gray-600">No results found</p>
                                            </div>
                                        )}

                                        {!loadingResults && currentSearch && filteredResults.length > 0 && (
                                            <div className="space-y-6 mt-6">
                                                {Object.entries(groupedByLanguageAndPos)
                                                    .sort(([a], [b]) => getLangName(a).localeCompare(getLangName(b)))
                                                    .map(([lang, posByLang]) => (
                                                    <div key={lang} className="bg-white rounded shadow">
                                                        <button
                                                            onClick={() => toggleSection(`lang-${lang}`)}
                                                            className="w-full px-4 py-3 flex items-center justify-between hover:bg-gray-50"
                                                        >
                                                            <h3 className="text-lg font-bold text-gray-800">
                                                                {getLangName(lang)}
                                                            </h3>
                                                            <span className="text-gray-500">
                                                                {collapsedSections[`lang-${lang}`] ? 'â–¶' : 'â–¼'}
                                                            </span>
                                                        </button>

                                                        {!collapsedSections[`lang-${lang}`] && (
                                                            <div className="px-4 pb-4 space-y-4">
                                                                {Object.entries(posByLang)
                                                                    .sort(([a], [b]) => {
                                                                        const order = ['NOUN', 'VERB', 'ADJ', 'ADV', 'CONJ', 'ADP', 'NREF', 'UNK'];
                                                                        return order.indexOf(a) - order.indexOf(b);
                                                                    })
                                                                    .map(([pos, groups]) => (
                                                                    <div key={pos} className="pl-1">
                                                                        {!senseFilter && (
                                                                            <button
                                                                                onClick={() => toggleSection(`pos-${lang}-${pos}`)}
                                                                                className="w-full flex items-center justify-between py-2 hover:bg-gray-50"
                                                                            >
                                                                                <h4 className="font-semibold text-gray-700">
                                                                                    {getPosName(pos, true)}
                                                                                </h4>
                                                                                <span className="text-gray-400 text-sm">
                                                                                    {collapsedSections[`pos-${lang}-${pos}`] ? 'â–¶' : 'â–¼'}
                                                                                </span>
                                                                            </button>
                                                                        )}

                                                                        {(!collapsedSections[`pos-${lang}-${pos}`] || senseFilter) && (
                                                                            <div className="space-y-3 mt-2">
                                                                                {groups.map((group, idx) => {
                                                                                    const concept = getConceptData(group.conceptId);

                                                                                    return (
                                                                                        <div key={idx} className="space-y-2">
                                                                                            {group.senses.map(sense => {
                                                                                                // Get synonyms (other senses in same language for this concept)
                                                                                                const synonyms = [];
                                                                                                if (concept?.s?.[lang]) {
                                                                                                    concept.s[lang].forEach(senseId => {
                                                                                                        const otherSense = loadedSenses[senseId.toString()];
                                                                                                        if (otherSense && senseId.toString() !== sense.id.toString() && otherSense.l !== sense.l) {
                                                                                                            synonyms.push(otherSense.l);
                                                                                                        }
                                                                                                    });
                                                                                                }

                                                                                                const definition = concept?.d?.[definitionLanguage] || concept?.d?.en || '';

                                                                                                return (
                                                                                                        <div
                                                                                                            key={sense.id}
                                                                                                            className="bg-gray-50 p-3 rounded border border-gray-200 hover:border-blue-400 cursor-pointer sense-box"
                                                                                                            onClick={() => toggleSynonyms(sense.id)}
                                                                                                        >
                                                                                                            <div className="flex items-start justify-between gap-2">
                                                                                                            <div className="flex-grow flex items-start gap-2">
                                                                                                                <div className="flex-shrink-0 py-1">
                                                                                                                    <strong className="text-base">{sense.l}<sub>{sense.ind}</sub></strong>
                                                                                                                </div>
                                                                                                                <div
                                                                                                                    onClick={(e) => {
                                                                                                                        e.stopPropagation();
                                                                                                                        handleConceptClick(group.conceptId);
                                                                                                                    }}
                                                                                                                    className="bg-white px-2 py-1 rounded border border-gray-300 hover:border-blue-400 hover:shadow-sm transition-all text-left cursor-pointer flex-shrink concept-inner"
                                                                                                                >
                                                                                                                    <span className="text-base">
                                                                                                                        <span className="text-gray-600 italic">
                                                                                                                            {getPosName(pos)}.
                                                                                                                        </span>
                                                                                                                        {' '}
                                                                                                                        <span className="text-gray-700">
                                                                                                                            {definition}
                                                                                                                        </span>
                                                                                                                    </span>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <div className="text-gray-500 text-sm pt-1 flex-shrink-0">
                                                                                                                {synonymsCollapsed[sense.id] === false ? 'â–¼' : 'â–¶'}
                                                                                                            </div>
                                                                                                        </div>

                                                                                                        {synonymsCollapsed[sense.id] === false && (
                                                                                                            <div className="mt-2 space-y-2">
                                                                                                                {sense.v && sense.v.length > 0 && (
                                                                                                                    <div className="text-sm text-gray-600">
                                                                                                                        <span className="font-medium">Variants:</span>
                                                                                                                        {' '}
                                                                                                                        {sense.v.map((variant, varIdx) => (
                                                                                                                            <span key={varIdx}>
                                                                                                                                {varIdx > 0 && ', '}
                                                                                                                                <span
                                                                                                                                    onClick={(e) => {
                                                                                                                                        e.stopPropagation();
                                                                                                                                        handleWordformClick(variant);
                                                                                                                                    }}
                                                                                                                                    className="text-blue-600 hover:underline cursor-pointer"
                                                                                                                                >
                                                                                                                                    {variant}
                                                                                                                                </span>
                                                                                                                            </span>
                                                                                                                        ))}
                                                                                                                    </div>
                                                                                                                )}

                                                                                                                {synonyms.length > 0 && (
                                                                                                                    <div className="text-sm text-gray-600">
                                                                                                                        <span className="font-medium">Synonyms:</span>
                                                                                                                        {' '}
                                                                                                                        {synonyms.map((syn, synIdx) => (
                                                                                                                            <span key={synIdx}>
                                                                                                                                {synIdx > 0 && ', '}
                                                                                                                                <span
                                                                                                                                    onClick={(e) => {
                                                                                                                                        e.stopPropagation();
                                                                                                                                        handleWordformClick(syn);
                                                                                                                                    }}
                                                                                                                                    className="text-blue-600 hover:underline cursor-pointer"
                                                                                                                                >
                                                                                                                                    {syn}
                                                                                                                                </span>
                                                                                                                            </span>
                                                                                                                        ))}
                                                                                                                    </div>
                                                                                                                )}

                                                                                                                {sense.ex && sense.ex.length > 0 && (
                                                                                                                    <div className="text-sm text-gray-600">
                                                                                                                        <span className="font-medium">Examples:</span>
                                                                                                                        {' '}
                                                                                                                        {sense.ex.map((ex, exIdx) => (
                                                                                                                            <span key={exIdx}>
                                                                                                                                {exIdx > 0 && '; '}
                                                                                                                                "{renderExample(ex)}"
                                                                                                                            </span>
                                                                                                                        ))}
                                                                                                                    </div>
                                                                                                                )}

                                                                                                                {!sense.v?.length && synonyms.length === 0 && !sense.ex?.length && (
                                                                                                                    <div className="text-sm text-gray-600 italic">
                                                                                                                        No additional information
                                                                                                                    </div>
                                                                                                                )}
                                                                                                            </div>
                                                                                                        )}
                                                                                                    </div>
                                                                                                );
                                                                                            })}
                                                                                        </div>
                                                                                    );
                                                                                })}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                )}

                                {view === 'concept' && selectedConcept && (
                                    <div>
                                        <button
                                            onClick={handleBackToSearch}
                                            className="mb-4 text-blue-600 hover:underline"
                                        >
                                            â† Back to search
                                        </button>
                                        {(() => {
                                            const concept = getConceptData(selectedConcept);

                                            // Load all senses for this concept
                                            if (concept?.s) {
                                                Object.values(concept.s).flat().forEach(senseId => {
                                                    if (!loadedSenses[senseId.toString()]) {
                                                        loadSense(senseId.toString());
                                                    }
                                                });
                                            }

                                            const mainDefinition = concept?.d?.en || '(No English definition available)';
                                            const alternativeDefinitions = concept?.d ? Object.entries(concept.d)
                                                .filter(([lang, def]) => lang !== 'en' && def)
                                                : [];

                                            return concept ? (
                                                <div>
                                                    <div className="mb-4">
                                                        <p className="text-base">
                                                            <span className="text-gray-600 italic">
                                                                {getPosName(concept.oc)}.
                                                            </span>
                                                            {' '}
                                                            {concept.da ? renderDefinitionWithLinks(mainDefinition, concept.da) : mainDefinition}
                                                        </p>
                                                    </div>

                                                    {/* Concept Relations Graph (Now conditionally rendered) */}
                                                    {relationsMap && hasRelationsToDisplay && (
                                                        <div className="mb-4">
                                                            <h3 className="font-bold mb-2 text-base">Related Concepts:</h3>
                                                            <div style={{ position: 'relative', overflow: 'hidden' }}>
                                                                <div
                                                                    id="concept-graph"
                                                                    style={{ width: '100%', height: '500px' }}
                                                                />
                                                                <div className="text-sm text-gray-600 italic mt-2 text-left">
                                                                    Hover over a node to expand its relations.
                                                                </div>
                                                                {hoveredNode && hoverMenuPosition && (
                                                                    <div
                                                                        style={{
                                                                            position: 'absolute',
                                                                            left: hoverMenuPosition.x,
                                                                            top: hoverMenuPosition.y,
                                                                            zIndex: 1000,
                                                                            pointerEvents: 'auto',
                                                                            maxWidth: `calc(100% - ${hoverMenuPosition.x}px)`,
                                                                            maxHeight: `${500 - hoverMenuPosition.y}px`,
                                                                            overflow: 'hidden'
                                                                        }}
                                                                    >
                                                                    <div
                                                                        ref={menuRef}
                                                                        onMouseEnter={() => {
                                                                            // Cancel any pending timeout when mouse enters menu
                                                                            if (hoverTimeoutRef.current) {
                                                                                clearTimeout(hoverTimeoutRef.current);
                                                                                hoverTimeoutRef.current = null;
                                                                            }
                                                                        }}
                                                                        onMouseMove={() => {
                                                                            // Also cancel timeout on mouse movement for extra safety
                                                                            if (hoverTimeoutRef.current) {
                                                                                clearTimeout(hoverTimeoutRef.current);
                                                                                hoverTimeoutRef.current = null;
                                                                            }
                                                                        }}
                                                                        onMouseLeave={() => {
                                                                            hoverTimeoutRef.current = setTimeout(() => {
                                                                                setHoveredNode(null);
                                                                                setHoverMenuPosition(null);
                                                                            }, 100);
                                                                        }}
                                                                        onMouseDown={() => {
                                                                            menuInteractionRef.current = true;
                                                                        }}
                                                                        onClick={() => {
                                                                            // Keep menu open briefly after click
                                                                            setTimeout(() => {
                                                                                menuInteractionRef.current = false;
                                                                            }, 50);
                                                                        }}
                                                                        className="bg-white border-2 border-gray-400 rounded shadow-lg p-2 text-sm min-w-[150px]"
                                                                    >
                                                                        <div className="font-semibold mb-2 text-gray-700 text-xs">Relations:</div>
                                                                        {getAvailableCategories(hoveredNode).map(category => {
                                                                            const isSelected = selectedCategories[hoveredNode]?.has(category);
                                                                            return (
                                                                                <button
                                                                                    key={category}
                                                                                    onClick={() => handleCategorySelect(hoveredNode, category)}
                                                                                    className={`block w-full text-left px-2 py-1 rounded flex items-center gap-2 ${
                                                                                        isSelected ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'
                                                                                    }`}
                                                                                >
                                                                                    <span className="w-4">{isSelected ? 'â˜‘' : 'â˜'}</span>
                                                                                    <span>{category.charAt(0).toUpperCase() + category.slice(1)}</span>
                                                                                </button>
                                                                            );
                                                                        })}
                                                                        {getAvailableCategories(hoveredNode).length === 0 && (
                                                                            <div className="text-gray-500 italic px-2">
                                                                                No relations
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                        </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {alternativeDefinitions.length > 0 && (
                                                        <div className="mb-4">
                                                            <h3 className="font-bold mb-2 text-base">Alternative definitions:</h3>
                                                            <div className="space-y-1 ml-2">
                                                                {alternativeDefinitions.map(([lang, def]) => (
                                                                    <div key={lang} className="text-sm">
                                                                        <span className="font-semibold text-gray-700">{getLangName(lang)}:</span> {def}
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}

                                                    <div className="mb-4">
                                                        <h3 className="font-bold mb-2 text-base">All forms expressing this concept:</h3>
                                                        <div className="space-y-1 ml-2">
                                                            {concept.s && Object.entries(concept.s)
                                                                .sort(([a], [b]) => getLangName(a).localeCompare(getLangName(b)))
                                                                .map(([lang, senseIds]) => {
                                                                    const lemmas = senseIds
                                                                        .map(senseId => {
                                                                            const senseData = loadedSenses[senseId.toString()];
                                                                            return senseData ? { lemma: senseData.l, senseId: senseId.toString() } : null;
                                                                        })
                                                                        .filter(item => item !== null);

                                                                    return (
                                                                        <div key={lang} className="text-sm">
                                                                            <span className="font-semibold text-gray-700">{getLangName(lang)}:</span>
                                                                            {' '}
                                                                            {lemmas.map((item, idx) => (
                                                                                <span key={item.senseId}>
                                                                                    {idx > 0 && ', '}
                                                                                    <button
                                                                                        onClick={() => handleWordformClickWithSense(item.lemma, item.senseId)}
                                                                                        className="text-blue-600 hover:underline"
                                                                                    >
                                                                                        {item.lemma}
                                                                                    </button>
                                                                                </span>
                                                                            ))}
                                                                        </div>
                                                                    );
                                                                })}
                                                        </div>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="text-gray-600">Loading concept...</div>
                                            );
                                        })()}
                                    </div>
                                )}

                                {view === 'sense' && selectedSense && (
                                    <div>
                                        <button
                                            onClick={handleBackToSearch}
                                            className="mb-4 text-blue-600 hover:underline"
                                        >
                                            â† Back to search
                                        </button>

                                        {loadedSenses[selectedSense] ? (
                                            <div>
                                                <div className="mb-4">
                                                    <h2 className="text-2xl font-bold mb-2">
                                                        {loadedSenses[selectedSense].l}
                                                    </h2>
                                                    <p className="text-gray-600">
                                                        Language: {getLangName(loadedSenses[selectedSense].lg)}
                                                    </p>
                                                </div>

                                                {loadedSenses[selectedSense].v && loadedSenses[selectedSense].v.length > 0 && (
                                                    <div className="mb-4">
                                                        <h3 className="font-bold mb-2">Variants:</h3>
                                                        <div className="ml-2 space-y-1">
                                                            {loadedSenses[selectedSense].v.map((variant, idx) => (
                                                                <div key={idx}>
                                                                    <button
                                                                        onClick={() => handleWordformClick(variant)}
                                                                        className="text-blue-600 hover:underline"
                                                                    >
                                                                        {variant}
                                                                    </button>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                <div className="mb-4">
                                                    <h3 className="font-bold mb-2">Concept:</h3>
                                                    <button
                                                        onClick={() => handleConceptClick(loadedSenses[selectedSense].c.toString())}
                                                        className="text-blue-600 hover:underline"
                                                    >
                                                        {loadedSenses[selectedSense].c}
                                                    </button>
                                                </div>

                                                {loadedSenses[selectedSense].ex && loadedSenses[selectedSense].ex.length > 0 && (
                                                    <div className="mb-4">
                                                        <h3 className="font-bold mb-2">Examples:</h3>
                                                        <div className="ml-2 space-y-1">
                                                            {loadedSenses[selectedSense].ex.map((ex, idx) => (
                                                                <div key={idx} className="text-gray-700">
                                                                    "{renderExample(ex)}"
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {loadedSenses[selectedSense].sr && Object.keys(loadedSenses[selectedSense].sr).length > 0 && (
                                                    <div className="mb-4">
                                                        <h3 className="font-bold mb-2">Sense Relations:</h3>
                                                        <div className="ml-2 space-y-1 text-sm">
                                                            {Object.entries(loadedSenses[selectedSense].sr).map(([relType, targets]) => (
                                                                targets.map((target, idx) => (
                                                                    <div key={`${relType}-${idx}`}>
                                                                        <span className="text-gray-600">{relType}:</span>{' '}
                                                                        <button
                                                                            onClick={() => handleSenseClick(target.toString())}
                                                                            className="text-blue-600 hover:underline"
                                                                        >
                                                                            {target}
                                                                        </button>
                                                                    </div>
                                                                ))
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        ) : (
                                            <div className="text-gray-600">Loading sense...</div>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}

                        {activeTab === 'python' && (
                            <div>
                                <h2 className="text-xl font-bold mb-4">Python Module</h2>
                                <p className="text-gray-600">Python module documentation coming soon.</p>
                            </div>
                        )}

                        {activeTab === 'data' && (
                            <div>
                                <h2 className="text-xl font-bold mb-4">Data Download</h2>
                                <p className="text-gray-600">Data download options coming soon.</p>
                            </div>
                        )}

                        {activeTab === 'about' && (
                            <div>
                                <h2 className="text-xl font-bold mb-4">About</h2>
                                <p className="text-gray-600">Information about Cygnet coming soon.</p>
                            </div>
                        )}

                        {activeTab === 'publications' && (
                            <div>
                                <h2 className="text-xl font-bold mb-4">Publications</h2>
                                <p className="text-gray-600">Publications information coming soon.</p>
                            </div>
                        )}
                    </main>

                    <footer className="mt-auto py-4">
                        <div className="max-w-4xl mx-auto px-4 border-t border-gray-200 pt-4">
                            <div className="max-w-4xl mx-auto text-center text-sm text-gray-600">
                                <div className="mb-2">
                                    <span>Produced with the support of</span>
                                </div>
                                <div>
                                    <a href="https://www.culturelab.psl.eu/" target="_blank" rel="noopener noreferrer" className="inline-block hover:opacity-80">
                                        <img src="website_data/culturelab.png" alt="Culture Lab" className="h-14 inline-block" />
                                    </a>
                                </div>
                            </div>
                        </div>
                    </footer>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DictionaryBrowser />);
    </script>
</body>
</html>